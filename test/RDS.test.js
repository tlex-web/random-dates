// Description: This file contains the unit tests for the Random Date Sampler application.
const assert = require('node:assert').strict

class DateError extends Error {
    /**
     * Custom error class for the random date application
     * gets the number of the field where the error occurs
     * to show the message in the frontend
     * @param {String} message
     * @param {Number | Number[]} field
     */
    constructor(message, field) {
        super(message)

        this.field = field
    }
}

/**
 * get the number of the month by providing the month as a 3 characters string
 * @param {String} month
 * @returns Number
 */
let monthNumberFromString = month => {
    return new Date(`${month} 01 2000`).toLocaleDateString(`en`, {
        month: `2-digit`,
    })
}

/**
 * Generate a random number between two numbers, including min and excluding max
 * @param {Number} min
 * @param {Number} max
 * @returns Number
 */
const getRandomInteger = (min, max) => {
    return Math.floor(Math.random() * (max - min)) + min
}

/**
 * Fetch public holidays from a public API and return them inside a promise
 * @param {String} country
 * @param {Date} start
 * @param {Date} end
 * @returns Promise<Date[]>
 */
const fetchPublicHolidays = async (country, start, end) => {
    const language = 'EN'

    const url = `https://openholidaysapi.org/PublicHolidays?countryIsoCode=${country}&languageIsoCode=${language}&validFrom=${start}&validTo=${end}`

    const res = await fetch(url)
    const data = await res.json()

    let holidays = []

    for (let i = 0; i < data.length; ++i) {
        holidays[i] = new Date(data[i].startDate)
    }

    return holidays
}

/**
 * Format a date to a string
 * @param {Date} date
 * @returns String
 */
const reformatDate = date => {
    return date.toLocaleDateString('en-CA')
}

class PRNG {
    /**
     * Pseudo random number generator
     * @param {Number} seed
     * @returns Instance of PRNG
     * @see https://en.wikipedia.org/wiki/Pseudorandom_number_generator
     * @see https://en.wikipedia.org/wiki/Mersenne_Twister
     */
    constructor(seed) {
        this._length = 624
        // The array holds the state of the generator
        this.mt = new Array(this._length)
        this.index = 0

        // Initialize the generator and set the first value as seed
        this.mt[0] = seed
        for (let i = 1; i < this._length; i++) {
            // The & 0xffffffff is necessary to get the same results as in the original code
            const prev = this.mt[i - 1]
            // Ensure that the value is different than the previous one
            this.mt[i] = (1812433253 * (prev ^ (prev >> 30)) + i) >>> 0
        }
    }

    /**
     * Generate a random number between two numbers, including min and max
     * @param {Number} min
     * @param {Number} max
     * @returns Number
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
     */
    next(min, max) {
        // Normalize to [0, 1]
        const randomNumber = this.generateRandomNumber() / 0xffffffff // Max 32-bit unsigned integer
        const range = max - min + 1
        // Round down to the nearest integer
        return Math.floor(randomNumber * range) + min
    }

    generateRandomNumber() {
        if (this.index === 0) {
            this.generateNumbers()
        }

        // Various bit manipulation operations are applied to y to ensure randomness.
        // These operations include bitwise shifting, XOR operations, and logical AND operations.
        // The specific bitwise manipulation is based on the Mersenne Twister algorithm.
        let y = this.mt[this.index]
        y ^= y >> 11
        y ^= (y << 7) & 0x9d2c5680 // 0x9d2c5680 = 2636928640
        y ^= (y << 15) & 0xefc60000 // 0xefc60000 = 4022730752
        y ^= y >> 18

        // If the index reaches the length of the array a new batch of untempered numbers is generated by calling generateNumbers()
        this.index = (this.index + 1) % this._length
        return y
    }

    generateNumbers() {
        // Generate an array of 624 untempered numbers
        // Each iteration mixes bits from the current number with bits from the next number
        for (let i = 0; i < this._length; i++) {
            const y = (this.mt[i] & 0x80000000) + (this.mt[(i + 1) % this._length] & 0x7fffffff) // 0x80000000 = 2147483648, 0x7fffffff = 2147483647
            this.mt[i] = this.mt[(i + 397) % 624] ^ (y >> 1)

            if (y % 2 !== 0) {
                this.mt[i] ^= 0x9908b0df // 0x9908b0df = 2567483615
            }
        }
    }
}

class RandomDateSampler {
    /**
     * Random date constructor class
     * @param {HTMLInputElement} start
     * @param {HTMLInputElement} end
     * @param {HTMLInputElement} batchSize
     * @param {HTMLInputElement} weekend
     * @param {HTMLInputElement} holidays
     * @param {HTMLInputElement} seed
     * @param {NodeList} errorFields
     * @returns RandomDateSampler
     */
    constructor(start, end, batchSize, weekend, holidays, seed, errorFields) {
        this._start = start.value.length !== 0 ? new Date(String(start.value)) : undefined
        this._end = end.value.length !== 0 ? new Date(String(end.value)) : undefined
        this._batchSize = +batchSize.value <= 0 ? Math.abs(batchSize.value) : +batchSize.value
        this._seed = +seed.value <= 0 ? Math.abs(seed.value) : +seed.value
        this._prng = new PRNG(this._seed)
        this._weekend = weekend.checked ? true : false
        this._holidays = holidays.checked ? true : false
        this._errorFields = errorFields
        this._batch = []
        this._holidays = []
        this._output = []
        this._isError = false
    }

    get error() {
        return this._isError
    }

    checkInput = () => {
        // check if the dates have been provided
        if (!this._start) throw new DateError('Provide a date', 0)
        if (!this._end) throw new DateError('Provide a date', 1)

        // check if the end date is greater than the start date
        if (this._start.valueOf() > this._end.valueOf())
            throw new DateError(
                `${this._end.toString().slice(0, 10)} needs to be greater than ${this._start.toString().slice(0, 10)}`,
                [0, 1]
            )

        // check if the dates have the same value
        if (+this._start === +this._end) throw new DateError('Define a valid range', [0, 1])

        // check if a number is provided
        if (this._batchSize <= 0) throw new DateError('Sample needs to be greater than 0', 2)

        if (this.getDatesInRange(new Date(this._start), new Date(this._end), this._weekend).length < this._batchSize)
            throw new DateError('Extend the time frame or pick a lower sample size', [0, 1, 2, 3])

        // check if the weekend checkbox is checked
        if (this._holidays instanceof Boolean) throw new DateError('Holidays are not implemented yet', 4)

        // check if the seed number is greater than 0
        if (this._seed <= 0) throw new DateError('Seed number needs to be greater than 0', 5)

        // 4294967295 = 2^32 - 1
        // check if the seed number is smaller than 4294967295
        if (this._seed > 4294967295) throw new DateError('Seed needs to be smaller than 4294967295', 5)
    }

    init() {
        try {
            this.checkInput()
            this._isError = false
        } catch (error) {
            const { message, field } = error

            if (typeof field === 'object') {
                this._isError = true

                field.forEach(e => {
                    this._errorFields[+e].innerHTML = message
                })
            } else {
                this._isError = true
                const n = +field

                this._errorFields[n].innerHTML = message
            }
        }
        if (this._isError) return false
        else return true
    }

    print() {
        return [this._start, this._end, this._seed, this._weekend, this._batchSize, this._errorFields]
    }

    /**
     * Returns all dates between start and end date
     * @param {Date} start
     * @param {Date} end
     * @param {Boolean} excludeWeekend
     * @returns Date[]
     */
    getDatesInRange = (start, end, excludeWeekend) => {
        if (typeof start !== 'object') throw new DateError('DateType', 1)
        if (typeof end !== 'object') throw new DateError('DateType', 2)

        const arr = []

        for (let dt = new Date(start); dt <= new Date(end); dt.setDate(dt.getDate() + 1)) {
            if (excludeWeekend) {
                if (dt.toString().slice(0, 3) !== 'Sat' && dt.toString().slice(0, 3) !== 'Sun') arr.push(new Date(dt))
            } else {
                arr.push(new Date(dt))
            }

            if (!arr?.length) throw new DateError("Couldn't create batch", 2)
        }

        return arr
    }

    /**
     * Create a batch with randomly selected dates of the size n
     * @param {Date[]} dates
     * @param {Number} n
     * @returns Dates[]
     */
    createRandomSampleBatch = async (dates, n) => {
        const holidays = await fetchPublicHolidays('LU', reformatDate(this._start), reformatDate(this._end))

        let batch = []
        let seeds = []
        let numDates = dates.length

        for (let i = 0; i < numDates; i++) {
            const seed = this._prng.next(0, numDates - 1)

            // If true, check if the date is a not a holiday
            if (this._holidays) {
                if (!holidays.includes(dates[seed]) && !seeds.includes(seed)) batch.push(dates[seed])
            } else {
                // Check if the index of the date has already been picked,
                // since the filtering for dates is unreliable
                if (!seeds.includes(seed)) batch.push(dates[seed])
            }

            if (batch.length === n) break

            seeds.push(seed)
        }

        if (batch.length !== n) throw new DateError('Extend the time frame or pick a lower sample size', 2)

        return batch
    }

    /**
     * Create the output element containing the date batch
     * @returns Object with the HTML elements and the raw dates array
     */
    createOutput = async () => {
        let batch = []
        try {
            const dates = this.getDatesInRange(new Date(this._start), new Date(this._end), this._weekend)

            batch = await this.createRandomSampleBatch(dates, this._batchSize).sort((a, b) => a - b)
        } catch (error) {
            const { message, field } = error

            this._isError = true

            if (!message || !field) throw new DateError(`${error}`, 2)
            else this._errorFields[+field].innerHTML = message
        }

        const output = []

        batch.forEach(date => output.push(`<li>${reformatDate(date)}</li>`))

        return { html_output: output, dates: batch }
    }
}

describe('RandomDateSampler class method tests - checkInput', function () {
    it('should throw an error if no start date is provided', function () {
        const start = { value: '' }
        const end = { value: '2021-01-02' }
        const batchSize = { value: 1 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 111 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Provide a date',
                field: 0,
            }
        )
    })

    it('should throw an error if no end date is provided', function () {
        const start = { value: '2021-01-01' }
        const end = { value: '' }
        const batchSize = { value: 1 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 111 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Provide a date',
                field: 1,
            }
        )
    })

    it('should throw an error if the start date is greater than the end date', function () {
        const start = { value: '2021-01-02' }
        const end = { value: '2021-01-01' }
        const batchSize = { value: 1 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 111 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Fri Jan 01 needs to be greater than Sat Jan 02',
                field: [0, 1],
            }
        )
    })

    it('should throw an error if the start date and end date are equal', function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-01' }
        const batchSize = { value: 1 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 111 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Define a valid range',
                field: [0, 1],
            }
        )
    })
    it('should throw an error if the batch size is less than 1', function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-02' }
        const batchSize = { value: 0 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 111 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Sample needs to be greater than 0',
                field: 2,
            }
        )
    })
    it('should throw an error if the batch size is greater than the range', function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-02' }
        const batchSize = { value: 3 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 111 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Extend the time frame or pick a lower sample size',
                field: [0, 1, 2, 3],
            }
        )
    })
    it('should throw an error if no seed number is provided', function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-02' }
        const batchSize = { value: 1 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: '' }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]
        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Seed number needs to be greater than 0',
                field: 5,
            }
        )
    })
    it('should throw an error if the seed number is not a number', function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-02' }
        const batchSize = { value: 1 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 'abc' }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]
        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Provide a seed number',
                field: 5,
            }
        )
    })
    it('should throw an error if the seed number is less than 1', function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-02' }
        const batchSize = { value: 1 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 0 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]
        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Seed number needs to be greater than 0',
                field: 5,
            }
        )
    })
    it('should throw an error if the seed number is greater than 4294967295', function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-02' }
        const batchSize = { value: 1 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 4294967296 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]
        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        assert.throws(
            () => {
                randomDateSampler.checkInput()
            },
            {
                name: 'Error',
                message: 'Seed needs to be smaller than 4294967295',
                field: 5,
            }
        )
    })
})

describe('RandomDateSampler class tests - createOutput', function () {
    it('should always create the same bath of dates using the same seed number', async function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-31' }
        const batchSize = { value: 5 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 111 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        const output = await randomDateSampler.createOutput()
        console.log(output.html_output)

        assert.deepEqual(output.html_output, [
            '<li>07/01/2021 </li>',
            '<li>08/01/2021 </li>',
            '<li>09/01/2021 </li>',
            '<li>10/01/2021 </li>',
            '<li>12/01/2021 </li>',
        ])
    })
    it('should fail to create the same bath of dates using a different seed number', async function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-31' }
        const batchSize = { value: 5 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 112 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        const output = await randomDateSampler.createOutput()

        assert.notDeepEqual(output.html_output, [
            '<li>07/01/2021 </li>',
            '<li>08/01/2021 </li>',
            '<li>09/01/2021 </li>',
            '<li>10/01/2021 </li>',
            '<li>12/01/2021 </li>',
        ])
    })
})

describe('RandomDateSampler class tests - createRandomSampleBatch', function () {
    it('should successfully create a batch without public holidays', async function () {
        const start = { value: '2021-01-01' }
        const end = { value: '2021-01-31' }
        const batchSize = { value: 5 }
        const weekend = { checked: false }
        const holidays = { checked: false }
        const seed = { value: 111 }
        const errorFields = [
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
            { innerHTML: '' },
        ]

        const randomDateSampler = new RandomDateSampler(start, end, batchSize, weekend, holidays, seed, errorFields)

        const output = await randomDateSampler.createRandomSampleBatch(
            ['07/01/2021', '08/01/2021', '09/01/2021', '10/01/2021', '11/01/2021'],
            3
        )
        assert.deepEqual(output, ['07/01/2021', '08/01/2021', '09/01/2021'])
    })
})
